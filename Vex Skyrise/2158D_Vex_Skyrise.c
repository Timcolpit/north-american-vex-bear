#pragma config(Motor,  port1,           frontRightMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           backRightMotor, tmotorVex393, openLoop)
#pragma config(Motor,  port3,           frontLeftMotor, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           backLeftMotor,  tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           liftLeft,       tmotorVex393, openLoop)
#pragma config(Motor,  port6,           liftRight,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           intakeLeft,     tmotorVeX393, openLoop)
#pragma config(Motor,  port8,           intakeRight,    tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define FULL_POWER 127
#define HALF_POWER 63
#define STOP 0

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

string mainBattery;
string backupBattery;

short programChoice;

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// Move drive at full power for timer milliseconds either forward (1) or backward (-1)
void moveForward(int direction, int timer=0) {
	// Check for function input error
	if(direction == 1 || direction == -1 || direction == 0){
		// Move at 100% power
		motor[frontRightMotor]	    = FULL_POWER * direction;
		motor[frontLeftMotor] 	    = FULL_POWER * direction;
		motor[backRightMotor]		= FULL_POWER * direction;
		motor[backLeftMotor]	 	= FULL_POWER * direction;
	}

	if(timer != 0) {
		// Wait timer ms
		wait1Msec(timer);

		// Stop
		motor[frontRightMotor]	 = STOP;
		motor[frontLeftMotor] 	 = STOP;
		motor[backRightMotor]	 = STOP;
		motor[backLeftMotor]	 = STOP;
	}
}

// Move drive at full power for timer milliseconds either forward (1) or backward (-1)
void moveBackward(int direction, int timer=0) {
	// Check for function input error
	if(direction == 1 || direction == -1 || direction == 0){
		// Move at 100% power
		motor[frontRightMotor]	    = -FULL_POWER * direction;
		motor[frontLeftMotor] 	    = -FULL_POWER * direction;
		motor[backRightMotor]		= -FULL_POWER * direction;
		motor[backLeftMotor]	 	= -FULL_POWER * direction;
	}

	if(timer != 0) {
		// Wait timer ms
		wait1Msec(timer);

		// Stop
		motor[frontRightMotor]	 = STOP;
		motor[frontLeftMotor] 	 = STOP;
		motor[backRightMotor]	 = STOP;
		motor[backLeftMotor]	 = STOP;
	}
}

// Move drive at full power for timer milliseconds either forward (1) or backward (-1)
void moveLeft(int direction, int timer=0) {
	// Check for function input error
	if(direction == 1 || direction == -1 || direction == 0){
		// Move at 100% power
		motor[frontRightMotor]	    = FULL_POWER * direction;
		motor[frontLeftMotor] 	    = -FULL_POWER * direction;
		motor[backRightMotor]		= -FULL_POWER * direction;
		motor[backLeftMotor]	 	= FULL_POWER * direction;
	}

	if(timer != 0) {
		// Wait timer ms
		wait1Msec(timer);

		// Stop
		motor[frontRightMotor]	 = STOP;
		motor[frontLeftMotor] 	 = STOP;
		motor[backRightMotor]	 = STOP;
		motor[backLeftMotor]	 = STOP;
	}
}

// Move drive at full power for timer milliseconds either forward (1) or backward (-1)
void moveRight(int direction, int timer=0) {
	// Check for function input error
	if(direction == 1 || direction == -1 || direction == 0){
		// Move at 100% power
		motor[frontRightMotor]	    = -FULL_POWER * direction;
		motor[frontLeftMotor] 	    = FULL_POWER * direction;
		motor[backRightMotor]		= FULL_POWER * direction;
		motor[backLeftMotor]	 	= -FULL_POWER * direction;
	}

	if(timer != 0) {
		// Wait timer ms
		wait1Msec(timer);

		// Stop
		motor[frontRightMotor]	 = STOP;
		motor[frontLeftMotor] 	 = STOP;
		motor[backRightMotor]	 = STOP;
		motor[backLeftMotor]	 = STOP;
	}
}
//Spin drive motors in opp. directions
void turnLeft(int direction, int timer=0) {
	// Check for function input error
	if(direction == 1 || direction == -1 || direction == 0){
		// Default Left Turn
		motor[frontRightMotor]	 = -FULL_POWER * direction;
		motor[frontLeftMotor] 	 = FULL_POWER * direction;
		motor[backRightMotor]	 = -FULL_POWER * direction;
		motor[backLeftMotor]	 = FULL_POWER * direction;
	}

	if(timer != 0) {
		// Wait timer ms
		wait1Msec(timer);

		// Stop
		motor[frontRightMotor]   = STOP;
		motor[frontLeftMotor]  	 = STOP;
		motor[backRightMotor]    = STOP;
		motor[backLeftMotor]     = STOP;
	}
}
//Spin drive motors in opp. directions
void turnRight(int direction, int timer=0) {
	// Check for function input error
	if(direction == 1 || direction == -1 || direction == 0){
		// Default Left Turn
		motor[frontRightMotor]	 = FULL_POWER * direction;
		motor[frontLeftMotor] 	 = -FULL_POWER * direction;
		motor[backRightMotor]	 = FULL_POWER * direction;
		motor[backLeftMotor]	 = -FULL_POWER * direction;
	}

	if(timer != 0) {
		// Wait timer ms
		wait1Msec(timer);

		// Stop
		motor[frontRightMotor]   = STOP;
		motor[frontLeftMotor]  	 = STOP;
		motor[backRightMotor]    = STOP;
		motor[backLeftMotor]     = STOP;
	}

}

// Move arm at full power for timer milliseconds either forward (1) or backward (-1)
void moveLift(int direction, int timer=0) {
	// Check for function input error
	if(direction == 1 || direction == -1 || direction == 0){
		// Move at 100% power
		motor[liftRight]	   	 = FULL_POWER * direction;
		motor[liftLeft]          = FULL_POWER * direction;
	}

	if(timer != 0) {
		// Wait timer ms
		wait1Msec(timer);

		// Stop
		motor[liftRight]	   	 = STOP;
		motor[liftLeft]          = STOP;
	}
}
// Move arm at full power for timer milliseconds either forward (1) or backward (-1)
void moveIntake(int direction, int timer=0) {
	// Check for function input error
	if(direction == 1 || direction == -1 || direction == 0){
		// Move at 100% power
		motor[intakeLeft]	   	 = FULL_POWER * direction;
		motor[intakeRight]       = FULL_POWER * direction;
	}

	if(timer != 0) {
		// Wait timer ms
		wait1Msec(timer);

		// Stop
		motor[intakeLeft]	   	 = STOP;
		motor[intakeRight]       = STOP;
	}
}




//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------


/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
void pre_auton(){

	bLCDBacklight = true;	// Turn on LCD Backlight

	clearLCDLine(0);
	clearLCDLine(1);

	//Display the Primary Robot battery voltage
	displayLCDString(0, 0, "Primary: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0, 'V'); //Build the value to be displayed
	displayNextLCDString(mainBattery);

	//Display the Backup battery voltage
	displayLCDString(1, 0, "Backup: ");
	sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');	//Build the value to be displayed
	displayNextLCDString(backupBattery);

	//Short delay for the LCD refresh rate
	waitForPress();

	// Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);

	wait1Msec(500);

	//Declare count variable to keep track of our choice

	int count = 0;

	while(nLCDButtons != centerButton)
	{
		//Switch case that allows the user to choose from 5 different options
		switch(count){

			case 0: //Display first choice
				displayLCDCenteredString(0, "Red Auto 1");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();

				//Increment or decrement "count" based on button press
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count--;
				}

				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count++;
				}
				break;
			case 1: //display 2nd choice
				displayLCDCenteredString(0, "Blue Auto 1");
				displayLCDCenteredString(1, "<     Enter    >");


				if(nLCDButtons == leftButton) {
					waitForRelease();
					count--;
				}
				else if(nLCDButtons == rightButton) {
					waitForRelease();
					count++;
				}
				break;

			default:
				count = 0;
				break;
		}

		switch(count){
			case 2: //Display 3rd choice
				displayLCDCenteredString(0, "Red Auto 2");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				//Increment or decrement "count" based on button press
				if(nLCDButtons == leftButton) {
					waitForRelease();
					count--;
				}

				else if(nLCDButtons == rightButton) {
					waitForRelease();
					count++;
				}
				break;

			case 3: //display 4th choice
				displayLCDCenteredString(0, "Blue Auto 2");
				displayLCDCenteredString(1, "<     Enter    >");


				if(nLCDButtons == leftButton) {
					waitForRelease();
					count--;
				}
				else if(nLCDButtons == rightButton) {
					waitForRelease();
					count++;
				}
				break;

				default:
				count = 0;
				break;

			case 4: //display 5th choice
				displayLCDCenteredString(0, "Skills Challenge");
				displayLCDCenteredString(1, "<     Enter    >");


				if(nLCDButtons == leftButton) {
					waitForRelease();
					count--;
				}
				else if(nLCDButtons == rightButton) {
					waitForRelease();
					count++;
				}
				break;

				default:
				count = 0;
				break;
		}
		//Clear LCD
		clearLCDLine(0);
		clearLCDLine(1);

		switch(count) {  //pick auto, display
			case 0: //Choice 1 from LCD
				displayLCDCenteredString(0, "Red Auto 1");
				displayLCDCenteredString(1, "is running!");
				wait1Msec(1000);
				programChoice = 1;
				break;

			case 1: //Choice 2 from LCD
				displayLCDCenteredString(0, "Blue Auto 1");
				displayLCDCenteredString(1, "is running!");
				wait1Msec(1000);
				programChoice = 2;
				break;

			case 2: //Choice 2 from LCD
				displayLCDCenteredString(0, "Red Auto 2");
				displayLCDCenteredString(1, "is running!");
				wait1Msec(1000);
				programChoice = 3;
				break;

			case 3: //Choice 3 from LCD
				displayLCDCenteredString(0, "Blue Auto 2");
				displayLCDCenteredString(1, "is running!");
				wait1Msec(1000);
				programChoice = 4;
				break;

			case 4: //Choice 3 from LCD
				displayLCDCenteredString(0, "Skills Challenge");
				displayLCDCenteredString(1, "is running!");
				wait1Msec(1000);
				programChoice = 5;
				break;

			default:
				displayLCDCenteredString(0, "No valid choice");
				displayLCDCenteredString(1, "was made!");
				wait1Msec(1000);
				break;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
    if(programChoice == 1){
    }
    if(programChoice == 2){
    }
    if(programChoice == 3){
    }
    if(programChoice == 4){
    }
    if(programChoice == 5){
    }
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{

	while (true)
	{
	          /* Drivetrain */

        //Right side of the robot is controlled by the right joystick, Y-axis
        motor[frontRightMotor]	= vexRT[Ch2];
        motor[backRightMotor] 	= vexRT[Ch2];

        //Left side of the robot is controlled by the left joystick, Y-axis
        motor[frontLeftMotor]   = vexRT[Ch3];
        motor[backLeftMotor]    = vexRT[Ch3];
////////////////////////////////////////////////////////////////////////
//
//    End of forward drive
//
////////////////////////////////////////////////////////////////////////

//Right side of the robot is controlled by the right joystick, X-axis
        motor[frontRightMotor]	= vexRT[Ch1];
        motor[backRightMotor] 	= vexRT[Ch1];

//Right side of the robot is controlled by the right joystick, X-axis
        motor[frontRightMotor]	= vexRT[Ch4];
        motor[backRightMotor] 	= vexRT[Ch4];
////////////////////////////////////////////////////////////////////////
//
//    End of sideways drive
//
////////////////////////////////////////////////////////////////////////
        

        /* Button Control */

    // Arm

    if(vexRT[Btn5U]) {
    moveLift(1); // Move arm up
    }
    else if(vexRT[Btn5D]) {
    moveLift(-1); // Move arm down
    }
    // If neither buttons 5U or 5D are pressed
    else {
    moveLift(0);	//don't move arm

    }
    if(vexRT[Btn8L]==1) //move arm up half speed
    {
    motor[liftLeft] = 64;
    motorliftRight] = 64;
    }
    if(vexRT[Btn8R]==1) //move arm down half speed
    {
    motor[liftLeft] = -64;
    motorliftRight] = -64;    }
    else {
    motor[liftLeft] = 0;
    motorliftRight] = 0;
    }
////////////////////////////////////////////////////////////////////////
//
//    End of Lift
//
////////////////////////////////////////////////////////////////////////

    }
}